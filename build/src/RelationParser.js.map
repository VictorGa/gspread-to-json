{"version":3,"sources":["../../develop/src/RelationParser.js"],"names":[],"mappings":";;;;;;;;;;;;;;uBAAoB,WAAW;;;;AAE/B,IAAM,UAAU,GAAG,YAAY,CAAC;AAChC,IAAM,OAAO,GAAG,SAAS,CAAC;;AAEnB,SAAS,cAAc,CAAC,SAAS,EACxC;;AAEI,QAAI,eAAe,GAAG,SAAS,CAAC,GAAG,CAAC,UAAA,QAAQ,EAAG;AAC3C,YAAI,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAC,QAAQ,CAAC,CAAC;AAC3C,YAAI,GAAG,GAAG,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,UAAA,CAAC;mBAAI,qBAAQ,QAAQ,CAAC,qBAAQ,WAAW,CAAC,CAAC,CAAC,CAAC;SAAA,CAAC,CAAC;AAC3F,iBAAS,CAAC,QAAQ,GAAG,GAAG,CAAC;AACzB,eAAO,SAAS,CAAC;KACpB,CAAC,CAAA;AACF,WAAO,CAAC,GAAG,CAAC,KAAK,EAAE,eAAe,CAAC,CAAC;;AAEpC,WAAO,eAAe,CAAC;CAC1B;;AAEM,SAAS,aAAa,CAAC,QAAQ,EAAE,IAAI,EAC5C,EAEC;;AAEM,SAAS,cAAc,CAAC,SAAS,EAAE,IAAI,EAC9C;AACI,aAAS,CAAC,OAAO,CAAC,UAAA,QAAQ,EAAI;;AAE1B,YAAI,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AAC/B,YAAI,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;;gDACZ,QAAQ,CAAC,QAAQ;;YAA/B,IAAI;YAAE,IAAI;;AAEf,YAAG,OAAO,IAAI,KAAK,YAAY,IAAI,OAAO,IAAI,KAAK,YAAY,EAC/D;AACI,mBAAO,CAAC,KAAK,CAAC,WAAW,GAAG,QAAQ,CAAC,IAAI,GAAG,IAAI,GAAG,QAAQ,CAAC,IAAI,GAAG,iBAAiB,CAAC,CAAC;SACzF;;AAED,YAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,UAAA,GAAG,EAAI;AAC7B,gBAAI,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;AACrB,gBAAI,UAAU,YAAA,CAAC;;AAEf,gBAAG,OAAO,IAAI,KAAK,OAAO,EAC1B;AACI,0BAAU,GAAG,IAAI,CAAC,GAAG,CAAC,UAAA,GAAG;2BAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAA,GAAG;+BAAI,GAAG,CAAC,IAAI,CAAC,KAAK,GAAG;qBAAA,CAAC;iBAAA,CAAC,CAAC,MAAM,CAAC,UAAA,GAAG;2BAAI,OAAO,GAAG,KAAK,WAAW;iBAAA,CAAC,CAAC;aACpH,MAED;AACI,0BAAU,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAA,GAAG;2BAAI,GAAG,CAAC,IAAI,CAAC,KAAK,IAAI;iBAAA,CAAC,CAAC;aAC1D;;AAED,eAAG,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC;;AAEvB,mBAAO,GAAG,CAAC;SACd,CAAC,CAAC;;AAEH,YAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;KAC9B,CAAC,CAAC;CACN","file":"RelationParser.js","sourcesContent":["import Parsers from './Parsers';\n\nconst tabInclude = 'tabInclude';\nconst tabFrom = 'tabFrom';\n\nexport function parseRelations(relations)\n{\n\n    let relationsParsed = relations.map(relation =>{\n        let relParsed = Object.assign({},relation);\n        let rel = relation.relation.split('->').map(r => Parsers.camelize(Parsers.cleanSpaces(r)));\n        relParsed.relation = rel;\n        return relParsed;\n    })\n    console.log('>>>', relationsParsed);\n\n    return relationsParsed;\n}\n\nexport function applyRelation(relation, tabs)\n{\n\n}\n\nexport function applyRelations(relations, tabs)\n{\n    relations.forEach(relation => {\n\n        let tabA = tabs[relation.tabA];\n        let tabB = tabs[relation.tabB];\n        let [keyA, keyB] = relation.relation;\n\n        if(typeof tabA === 'undefinded' || typeof tabB === 'undefinded')\n        {\n            console.error('Relation ' + relation.tabA + '->' + relation.tabB  +' does not exist');\n        }\n        //TabA includes element from TabB\n        tabA.rows = tabA.rows.map(row => {\n            let keys = row[keyA];\n            let keyObjects;\n\n            if(typeof keys === 'Array')\n            {\n                keyObjects = keys.map(key => tabB.rows.find(row => row[keyB] === key)).filter(row => typeof row !== 'undefined');\n            }\n            else\n            {\n                keyObjects = tabB.rows.find(row => row[keyB] === keys);\n            }\n\n            row[keyA] = keyObjects;\n\n            return row;\n        });\n\n        tabs[relation.tabA] = tabA;\n    });\n}"]}