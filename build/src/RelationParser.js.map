{"version":3,"sources":["../../develop/src/RelationParser.js"],"names":[],"mappings":";;;;;;;;;;;;;;uBAAoB,WAAW;;;;AAE/B,IAAM,UAAU,GAAG,YAAY,CAAC;AAChC,IAAM,OAAO,GAAG,SAAS,CAAC;;AAEnB,SAAS,cAAc,CAAC,SAAS,EACxC;;AAEI,QAAI,eAAe,GAAG,SAAS,CAAC,GAAG,CAAC,UAAA,QAAQ,EAAG;AAC3C,YAAI,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAC,QAAQ,CAAC,CAAC;AAC3C,YAAI,GAAG,GAAG,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,UAAA,CAAC;mBAAI,qBAAQ,QAAQ,CAAC,qBAAQ,WAAW,CAAC,CAAC,CAAC,CAAC;SAAA,CAAC,CAAC;AAC3F,iBAAS,CAAC,QAAQ,GAAG,GAAG,CAAC;AACzB,eAAO,SAAS,CAAC;KACpB,CAAC,CAAA;AACF,WAAO,CAAC,GAAG,CAAC,KAAK,EAAE,eAAe,CAAC,CAAC;;AAEpC,WAAO,eAAe,CAAC;CAC1B;;AAEM,SAAS,aAAa,CAAC,QAAQ,EAAE,IAAI,EAC5C,EAEC;;AAEM,SAAS,cAAc,CAAC,SAAS,EAAE,IAAI,EAC9C;AACI,aAAS,CAAC,OAAO,CAAC,UAAA,QAAQ,EAAI;;AAE1B,YAAI,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AAC/B,YAAI,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;;gDACZ,QAAQ,CAAC,QAAQ;;YAA/B,IAAI;YAAE,IAAI;;AAEf,YAAG,OAAO,IAAI,KAAK,YAAY,IAAI,OAAO,IAAI,KAAK,YAAY,EAC/D;AACI,mBAAO,CAAC,KAAK,CAAC,WAAW,GAAG,QAAQ,CAAC,IAAI,GAAG,IAAI,GAAG,QAAQ,CAAC,IAAI,GAAG,iBAAiB,CAAC,CAAC;SACzF;;AAED,YAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,UAAA,GAAG,EAAI;AAC7B,gBAAI,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;AACrB,gBAAI,UAAU,YAAA,CAAC;;AAEf,gBAAG,OAAO,IAAI,KAAK,OAAO,EAC1B;AACI,0BAAU,GAAG,IAAI,CAAC,GAAG,CAAC,UAAA,GAAG;2BAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAA,GAAG;+BAAI,GAAG,CAAC,IAAI,CAAC,KAAK,GAAG;qBAAA,CAAC;iBAAA,CAAC,CAAC,MAAM,CAAC,UAAA,GAAG;2BAAI,OAAO,GAAG,KAAK,WAAW;iBAAA,CAAC,CAAC;aACpH,MAED;AACI,0BAAU,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAA,GAAG;2BAAI,GAAG,CAAC,IAAI,CAAC,KAAK,IAAI;iBAAA,CAAC,CAAC;aAC1D;;AAED,eAAG,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC;;AAEvB,mBAAO,GAAG,CAAC;SACd,CAAC,CAAC;;AAEH,YAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;KAC9B,CAAC,CAAC;CACN","file":"RelationParser.js","sourcesContent":["import Parsers from './Parsers';\r\n\r\nconst tabInclude = 'tabInclude';\r\nconst tabFrom = 'tabFrom';\r\n\r\nexport function parseRelations(relations)\r\n{\r\n\r\n    let relationsParsed = relations.map(relation =>{\r\n        let relParsed = Object.assign({},relation);\r\n        let rel = relation.relation.split('->').map(r => Parsers.camelize(Parsers.cleanSpaces(r)));\r\n        relParsed.relation = rel;\r\n        return relParsed;\r\n    })\r\n    console.log('>>>', relationsParsed);\r\n\r\n    return relationsParsed;\r\n}\r\n\r\nexport function applyRelation(relation, tabs)\r\n{\r\n\r\n}\r\n\r\nexport function applyRelations(relations, tabs)\r\n{\r\n    relations.forEach(relation => {\r\n\r\n        let tabA = tabs[relation.tabA];\r\n        let tabB = tabs[relation.tabB];\r\n        let [keyA, keyB] = relation.relation;\r\n\r\n        if(typeof tabA === 'undefinded' || typeof tabB === 'undefinded')\r\n        {\r\n            console.error('Relation ' + relation.tabA + '->' + relation.tabB  +' does not exist');\r\n        }\r\n        //TabA includes element from TabB\r\n        tabA.rows = tabA.rows.map(row => {\r\n            let keys = row[keyA];\r\n            let keyObjects;\r\n\r\n            if(typeof keys === 'Array')\r\n            {\r\n                keyObjects = keys.map(key => tabB.rows.find(row => row[keyB] === key)).filter(row => typeof row !== 'undefined');\r\n            }\r\n            else\r\n            {\r\n                keyObjects = tabB.rows.find(row => row[keyB] === keys);\r\n            }\r\n\r\n            row[keyA] = keyObjects;\r\n\r\n            return row;\r\n        });\r\n\r\n        tabs[relation.tabA] = tabA;\r\n    });\r\n}"]}