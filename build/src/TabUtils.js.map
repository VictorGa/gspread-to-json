{"version":3,"sources":["../../develop/src/TabUtils.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;;;;;;;;;;;;;uBACO,WAAW;;;;yBACX,aAAa;;AAEjC,IAAM,OAAO,GAAG,QAAQ,CAAC;AACzB,IAAM,WAAW,GAAG,aAAa,CAAC;;AAE3B,SAAS,QAAQ,CAAC,GAAG,EAC5B;;AAEC,KAAI,MAAM,GAAG,EAAE,CAAC;AAChB,OAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAA,GAAG,EAC5B;AACC,QAAM,CAAC,GAAG,CAAC,GAAG,sBAAM,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;EAC9B,CAAC,CAAC;;AAEH,QAAO,MAAM,CAAC;CACd;;AAEM,SAAS,gBAAgB,CAAC,MAAM,EAAE,GAAG,EAC5C;AACC,KAAG,OAAO,GAAG,CAAC,EAAE,KAAK,WAAW,EAChC;AACC,MAAI,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC;AACnC,SAAO,KAAK,CAAC,EAAE,CAAC;;AAEhB,QAAM,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC;EACvB;CACD;;AAEM,SAAS,kBAAkB,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EACrD;AACC,QAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAA;CAC1B;;AAEM,SAAS,QAAQ,CAAC,WAAW,EAAE,GAAG,EACzC;AACC,KAAI,MAAM,GAAG,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;AACzC,KAAI,UAAU,GAAG,GAAG,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;AACjD,KAAI,IAAI,YAAA,CAAC;;;;AAIT,KAAG,UAAU,EACb;AACC,MAAI,GAAG,EAAE,CAAC;AACV,aAAW,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAA,GAAG;UAAI,qBAAQ,MAAM,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC;GAAA,CAAC,CAAC;EACzE,MAED;AACC,MAAI,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,UAAA,GAAG;UAAI,QAAQ,CAAC,GAAG,CAAC;GAAA,CAAC,CAAC;EAClD;;AAED,4BAAS,GAAG,EAAG,EAAC,IAAI,EAAJ,IAAI,EAAE,MAAM,EAAN,MAAM,EAAE,UAAU,EAAV,UAAU,EAAC,EAAE;CAC3C","file":"TabUtils.js","sourcesContent":["'use strict';\nimport Parsers from './Parsers';\nimport {parse} from './Tokenizer';\n\nconst dictKey = '__dict';\nconst objParseKey = '__obj_parse';\n\nexport function parseRow(row)\n{\n\n\tlet parsed = {};\n\tObject.keys(row).forEach(key =>\n\t{\n\t\tparsed[key] = parse(row[key]);\n\t});\n\n\treturn parsed;\n}\n\nexport function convertRowToDict(parent, row)\n{\n\tif(typeof row.id !== 'undefined')\n\t{\n\t\tlet clone = Object.assign({}, row);\n\t\tdelete clone.id;\n\n\t\tparent[row.id] = clone;\n\t}\n}\n\nexport function convertRowToObject(parent, row, value)\n{\n\tconsole.log('>> obj', row)\n}\n\nexport function parseTab(spreadsheet, tab)\n{\n\tlet isDict = tab.indexOf(dictKey) !== -1;\n\tlet isObjParse = tab.indexOf(objParseKey) !== -1;\n\tlet rows;\n\n\t//In case is a object should be deepened\n\t//Just couples of id-copy\n\tif(isObjParse)\n\t{\n\t\trows = {};\n\t\tspreadsheet[tab].forEach(row => Parsers.deepen(row.id, row.value, rows));\n\t}\n\telse\n\t{\n\t\trows = spreadsheet[tab].map(row => parseRow(row));\n\t}\n\n\treturn {[tab]: {rows, isDict, isObjParse}};\n}"]}